<!doctype html><html lang=en><head><title>Rust CI Cache :: arriven.wtf</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Deeper dive into different options for caching rust builds on CI and their problems"><meta name=keywords content="rust,ci,cache,build,ci/cd,github"><meta name=robots content="noodp"><link rel=canonical href=https://blog.arriven.wtf/posts/rust-ci-cache/><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4PPS2HRE0"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4PPS2HRE0",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://blog.arriven.wtf/styles.css><link rel="shortcut icon" href=https://blog.arriven.wtf/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.arriven.wtf/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Rust CI Cache"><meta property="og:description" content="Deeper dive into different options for caching rust builds on CI and their problems"><meta property="og:url" content="https://blog.arriven.wtf/posts/rust-ci-cache/"><meta property="og:site_name" content="arriven.wtf"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2023-01-09 16:28:35 +0200 +0200"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>arriven.wtf</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/links>Links</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/links>Links</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.arriven.wtf/posts/rust-ci-cache/>Rust CI Cache</a></h1><div class=post-meta><time class=post-date>2023-01-09 ::</time>
<span class=post-author>Bohdan Ivashko</span></div><span class=post-tags>#<a href=https://blog.arriven.wtf/tags/rust/>rust</a>&nbsp;
#<a href=https://blog.arriven.wtf/tags/ci/>ci</a>&nbsp;
#<a href=https://blog.arriven.wtf/tags/cache/>cache</a>&nbsp;</span><div class=post-content><div><p>Even though rust generally has better build times than C++ it still compares poorly to some other languages and CI workflows can take quite some time to run from scratch (i.e. one of the projects I&rsquo;ve worked on took 40 minutes to run its&rsquo; suite on github actions default workers, even though the project is far from being huge). Long workflows can reduce iteration speed, especially as teams grow, so generally we want to speed up the CI, and what&rsquo;s a better way to do that than to use a good old cache? Well, as it turns out, caching build dependencies and artifacts in rust may be not as straightforward as it seems at the first glance.</p><h2 id=general-approach>General approach<a href=#general-approach class=hanchor arialabel=Anchor>&#8983;</a></h2><p>If you were to take a look at the <a href=https://doc.rust-lang.org/cargo/index.html>cargo book</a> you&rsquo;d notice that it already covers the basics on how to cache downloaded <a href=https://doc.rust-lang.org/cargo/guide/cargo-home.html>packages</a> and <a href=https://doc.rust-lang.org/cargo/guide/build-cache.html>build artifacts</a>. But if it was as simple as that this article wouldn&rsquo;t exist in the first place, so let&rsquo;s dig a bit deeper.</p><p>I&rsquo;ll be using a small personal project inspired by one of the services I had to do for work. Originally it was written in a different language but to represent it in rust I&rsquo;ve decided to use axum as a web server, sled/rocksdb for storage, tracing for logging, and clap for cmdline args. It&rsquo;s a very simple service but it has enought dependencies to demonstrate the impact of different caching approaches. You can find the repo <a href=https://github.com/arriven/rust-ci-playground>here</a>.</p><p>The repo also includes a github actions workflow that has a couple of different cache configurations that I&rsquo;ll be comparing further.</p><h2 id=caching-downloaded-packages>Caching downloaded packages<a href=#caching-downloaded-packages class=hanchor arialabel=Anchor>&#8983;</a></h2><p>According to this <a href=https://doc.rust-lang.org/cargo/guide/cargo-home.html>chapter</a> of the cargo book all you need to do in order to cache downloaded packages is to simply cache <code>$CARGO_HOME</code> directory, but to be more efficient you can cache only specific subdirectories in it (<code>registry/cache/</code>, <code>registry/index/</code>, and <code>git/db/</code>. it also specifies that you could cache <code>bin/</code> subdirectory but that one is used for installed tools and you would often prefer to use other means to get them faster, like using an action that downloads pre-built binaries or using a build image with all the tools already pre-installed (the latter has questionable results on <a href=https://github.com/actions/cache/issues/924>github</a>)). In order to test this I included a <code>home</code> cache action (yes, I&rsquo;m not very creative when it comes to naming) into the repo that uses a following cache configuration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/cache@v3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/registry/index/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/registry/cache/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/git/db/</span>      
</span></span><span style=display:flex><span>    <span style=color:#f92672>key</span>: <span style=color:#ae81ff>${{ runner.os }}-home-${{ hashFiles(&#39;**/Cargo.lock&#39;) }}</span>
</span></span></code></pre></div><p><strong>Note</strong>: if you&rsquo;re wondering why the key uses hash of all the <code>Cargo.lock</code> files in the workspace - it&rsquo;s because caches in github actions are <a href=https://github.com/actions/toolkit/issues/505>immutable</a> (yes, even if you use a <a href=https://github.com/martijnhols/actions-cache>fork</a> that allows you to push them at will) so in order to have a newer entry you need to have a different key.</p><p>When running it, the first run that doesn&rsquo;t have any cache looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo test --locked --no-run
</span></span><span style=display:flex><span>    Updating crates.io index
</span></span><span style=display:flex><span> Downloading crates ...
</span></span><span style=display:flex><span>  Downloaded lazy_static v1.4.0
</span></span><span style=display:flex><span>  Downloaded clap_derive v4.0.21
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># a bunch of other crates being downloaded</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>  Downloaded pin-project-lite v0.2.9
</span></span><span style=display:flex><span>   Compiling proc-macro2 v1.0.49
</span></span><span style=display:flex><span>   Compiling unicode-ident v1.0.6
</span></span><span style=display:flex><span>   <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># a bunch of other crates being compiled</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>   Compiling tracing-subscriber v0.3.16
</span></span><span style=display:flex><span>   Compiling linkmapper v0.1.0 <span style=color:#f92672>(</span>/home/runner/work/rust-ci-playground/rust-ci-playground<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 1m 09s
</span></span><span style=display:flex><span>  Executable unittests src/main.rs <span style=color:#f92672>(</span>target/debug/deps/linkmapper-da17f15a9210ca29<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>When running it for the second time the logs look slightly different:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Run cargo test --locked --no-run
</span></span><span style=display:flex><span>   Compiling proc-macro2 v1.0.49
</span></span><span style=display:flex><span>   Compiling unicode-ident v1.0.6
</span></span><span style=display:flex><span>   <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># a bunch of other crates being compiled</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>   Compiling tracing-subscriber v0.3.16
</span></span><span style=display:flex><span>   Compiling linkmapper v0.1.0 <span style=color:#f92672>(</span>/home/runner/work/rust-ci-playground/rust-ci-playground<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 52.84s
</span></span><span style=display:flex><span>  Executable unittests src/main.rs <span style=color:#f92672>(</span>target/debug/deps/linkmapper-da17f15a9210ca29<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>As you can notice, we no longer have to update crates.io index and it doesn&rsquo;t need to re-download the crates. This shaves about 30-45s off of the overall build time, which is nice. The cache ends up taking 86mb of space after being compressed by github (100mb for the <code>rocksdb</code> version), so it probably won&rsquo;t result in any cache eviction <a href=https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#force-deleting-cache-entries>issues</a>.</p><h2 id=caching-build-artifacts>Caching build artifacts<a href=#caching-build-artifacts class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Now let&rsquo;s take a look at another <a href=https://doc.rust-lang.org/cargo/guide/build-cache.html>chapter</a> of the cargo book. According to it we can cache the build artifacts by caching the <code>target</code> directory of our workspace or by using some third-party tools like <a href=https://github.com/mozilla/sccache>sccache</a> (<strong>Note</strong>: there are also other ways to achieve this if you use build systems other than cargo but I won&rsquo;t cover that here). All of the approaches benefit from disabling incremental build since it only slows down compilation and doesn&rsquo;t work well with caching.</p><h3 id=target-based-cache><strong><code>target</code>-based cache</strong><a href=#target-based-cache class=hanchor arialabel=Anchor>&#8983;</a></h3><p>I&rsquo;ll be using the following cache configuration to test it out (called <code>home_and_target</code> in the workflow file):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/cache@v3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/registry/index/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/registry/cache/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/git/db/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      target/</span>      
</span></span><span style=display:flex><span>    <span style=color:#f92672>key</span>: <span style=color:#ae81ff>${{ runner.os }}-home_and_target-${{ hashFiles(&#39;**/Cargo.lock&#39;) }}</span>
</span></span></code></pre></div><p>Again, the first run didn&rsquo;t show anything unexpected, without the cache being populated we still have to download and compile everything:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo test --locked --no-run
</span></span><span style=display:flex><span>    Updating crates.io index
</span></span><span style=display:flex><span> Downloading crates ...
</span></span><span style=display:flex><span>  Downloaded lazy_static v1.4.0
</span></span><span style=display:flex><span>  Downloaded clap_derive v4.0.21
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># a bunch of other crates being downloaded</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>  Downloaded pin-project-lite v0.2.9
</span></span><span style=display:flex><span>   Compiling proc-macro2 v1.0.49
</span></span><span style=display:flex><span>   Compiling unicode-ident v1.0.6
</span></span><span style=display:flex><span>   <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># a bunch of other crates being compiled</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>   Compiling tracing-subscriber v0.3.16
</span></span><span style=display:flex><span>   Compiling linkmapper v0.1.0 <span style=color:#f92672>(</span>/home/runner/work/rust-ci-playground/rust-ci-playground<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 1m 09s
</span></span><span style=display:flex><span>  Executable unittests src/main.rs <span style=color:#f92672>(</span>target/debug/deps/linkmapper-da17f15a9210ca29<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>On the second run the situation is a lot better, though:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo test --locked --no-run
</span></span><span style=display:flex><span>   Compiling linkmapper v0.1.0 <span style=color:#f92672>(</span>/home/runner/work/rust-ci-playground/rust-ci-playground<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 3.73s
</span></span><span style=display:flex><span>  Executable unittests src/main.rs <span style=color:#f92672>(</span>target/debug/deps/linkmapper-da17f15a9210ca29<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>As you can notice, now we didn&rsquo;t have to neither download nor compile any of the crates. But wait, our own code didn&rsquo;t change between the runs too, shouldn&rsquo;t it be cached? Why do we see <code>Compiling linkmapper v0.1.0 ...</code> in the logs? Well, as it turns out, cargo uses mtime to detect whether the source code has been changed and since CI runners clone the repo from scratch for each job it results in updated mtime (dependencies are unpacked with tar which saves mtime and aren&rsquo;t affected by this). There&rsquo;s an <a href=https://github.com/rust-lang/cargo/issues/6529>open issue</a> to address that but for now if your project has a lot of custom code compared to dependencies you can restore the mtime manually to the time of the commit using <a href=https://github.com/chetan/git-restore-mtime-action>this</a> github action or its&rsquo; <a href=https://github.com/chetan/git-restore-mtime-action/blob/master/src/git-restore-mtime-bare>underlying script</a> if you use some other CI systems (thankfully the script doesn&rsquo;t have a lot of dependencies). My updated cache configuration looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/cache@v3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/registry/index/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/registry/cache/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/git/db/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      target/</span>      
</span></span><span style=display:flex><span>    <span style=color:#f92672>key</span>: <span style=color:#ae81ff>${{ runner.os }}-home_and_target-${{ hashFiles(&#39;**/Cargo.lock&#39;) }}</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>chetan/git-restore-mtime-action@v1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>if</span>: <span style=color:#ae81ff>${{ inputs.restore_mtime }}</span>
</span></span></code></pre></div><p>Running it again finally gives us the expected result, and the overall build becomes almost instant for the perfect cache hit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo test --locked --no-run
</span></span><span style=display:flex><span>    Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.62s
</span></span><span style=display:flex><span>  Executable unittests src/main.rs <span style=color:#f92672>(</span>target/debug/deps/linkmapper-da17f15a9210ca29<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>I&rsquo;ve never seen this approach being used even though its&rsquo; only downside I know of is that it completely replicates the way <code>cargo</code> caches dependencies locally: if you ever had cases where <code>cargo</code> didn&rsquo;t pick up changes to the code introduced by <code>git pull</code> or similar - there&rsquo;s a non-zero chance you can encounter that on CI. Manually cleaning caches on github is fairly easy (unless you have lots of them) and you can use PR labels to conditionally disable cache usage so my guess is that this approach isn&rsquo;t widely adopted because most people just don&rsquo;t know about it (this is kind of confirmed by people who were reviewing the draft of this article).</p><p><strong>Except if we use <code>rocksdb</code> instead of <code>sled</code></strong></p><p>For some reason not including <code>$CARGO_HOME/registry/src</code> to the cache leads to full recompilation of <code>librocksdb-sys</code> and everything that depends on it (~I suspect <code>bindgen</code> as the culprit but this needs further testing~ Edit: it turns out there&rsquo;s an <a href=https://github.com/rust-lang/cargo/issues/11083>issue</a> and it&rsquo;s caused by <code>rocksdb</code> using <code>rerun-if-changed</code> on a folder in <code>build.rs</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo test --locked --no-run
</span></span><span style=display:flex><span>   Compiling librocksdb-sys v0.8.0+7.4.4
</span></span><span style=display:flex><span>   Compiling rocksdb v0.19.0
</span></span><span style=display:flex><span>   Compiling linkmapper v0.1.0 <span style=color:#f92672>(</span>/home/runner/work/rust-ci-playground/rust-ci-playground<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 9m 48s
</span></span><span style=display:flex><span>  Executable unittests src/main.rs <span style=color:#f92672>(</span>target/debug/deps/linkmapper-6393465c78bf12f8<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Yes, it takes more than 9 minutes to compile <code>rocksdb</code> on the github runner. This is definitely not something we want if we do need to use rocksdb. Fortunatelly, including the whole <code>$CARGO_HOME</code> into the cache solves this issue (<code>full</code> cache configuration in the repo):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/cache@v3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ~/.cargo/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      target/</span>      
</span></span><span style=display:flex><span>    <span style=color:#f92672>key</span>: <span style=color:#ae81ff>${{ runner.os }}-full-${{ hashFiles(&#39;**/Cargo.lock&#39;) }}</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>chetan/git-restore-mtime-action@v1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>if</span>: <span style=color:#ae81ff>${{ inputs.restore_mtime }}</span>
</span></span></code></pre></div><p><strong>Note:</strong> based on my <a href=https://github.com/arriven/rust-ci-playground/actions/runs/3782411644/jobs/6430124523>tests</a> just adding <code>$CARGO_HOME/registry/src</code> to the <code>home_and_target</code> cache is enought to fix this, but since <code>$CARGO_HOME</code> content is unstable it&rsquo;s safer to just cache the full thing, it&rsquo;s not that much overhead compared to the <code>target</code> folder size.</p><p><strong>Note 2:</strong> similar issue occurs if you have a git-based dependency and don&rsquo;t include <code>$CARGO_HOME/git/checkouts</code> into the cache, except in that case it also forces cargo to re-download any git submodule that package depends on</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo test --locked --no-run
</span></span><span style=display:flex><span>    Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 1.86s
</span></span><span style=display:flex><span>  Executable unittests src/main.rs <span style=color:#f92672>(</span>target/debug/deps/linkmapper-6393465c78bf12f8<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>The resulting cache size is 250 mb (830 mb for <code>rocksdb</code> version).</p><p><code>target</code>-based cache can end up being a bit bloated and I&rsquo;ve definitely seen a project where the time saved on build was negated by the time it took to sync the cache (to be fair, the cache was reaching 5GB at some point in compressed state and the project was using self-hosted gitlab runners which are more powerful than default github runners but have worse caching techniques). You also probably want to use something like <a href=https://github.com/holmgr/cargo-sweep>cargo sweep</a> to avoid infinite growth of the cache with old build artifacts unless you clean it up regularly or use more elaborate caching schemes (like building the cache from scratch on push to main and only restoring it in PRs).</p><p>If you go down this road and only care about caching dependencies (and don&rsquo;t have dependencies like <code>rocksdb</code>) you can also use <a href=https://github.com/Swatinem/rust-cache>Swatinem/rust-cache</a> which uses the same caching scheme as <code>home_and_target</code> but builds a more sensitive cache key and cleans up the cached directories from old build artifacts and non-deps objects.</p><p><strong>Note</strong>: it&rsquo;s possible to only cache the <code>target</code> dir and avoid caching <code>$CARGO_HOME</code> and it even will result in almost no recompilation (<code>rocksdb</code> is one of the exceptions again) but it&rsquo;s a rather weird caching setup, especially considering the size difference between cargo home and build artifacts for larger projects. Still, here&rsquo;s a build log for it to confirm that it works as expected if you&rsquo;re interested:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo build
</span></span><span style=display:flex><span>    Updating crates.io index
</span></span><span style=display:flex><span>  Downloaded fnv v1.0.7
</span></span><span style=display:flex><span>  Downloaded futures-channel v0.3.25
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># a bunch of other crates being downloaded</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>  Downloaded linux-raw-sys v0.1.4
</span></span><span style=display:flex><span>  Downloaded <span style=color:#ae81ff>96</span> crates <span style=color:#f92672>(</span>6.6 MB<span style=color:#f92672>)</span> in 1.18s
</span></span><span style=display:flex><span>    Finished dev <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 39.47s
</span></span></code></pre></div><h3 id=using-sccache><strong>Using <code>sccache</code></strong><a href=#using-sccache class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Mozilla&rsquo;s <a href=https://github.com/mozilla/sccache>sccache</a> uses a different approach for caching build artifacts - it acts as a distributed compilation cache, that can be backed by a local or cloud storage. It still leads to all the packages being recompiled (from the cargo perspective), but that compilation takes noticeably less time. It also doesn&rsquo;t affect calls to linker. If you end up pointing it to a cloud-based cache you could even set it up on your dev machines to speed up local compilation time.</p><p>Although I might be unlucky, <code>sccache</code> does seem to slow down the initial compilation time a bit (5-10%). Other than that there are no suprises here, it results in worse compilation time on a &lsquo;perfect&rsquo; cache hit than the <code>target</code>-base approach (about 5x speedup from the raw compilation time but it would be hard to compete with skipping the compilation completely), and the cache ends up taking only 170mb (490 mb for <code>rocksdb</code> version), which might end up being crucial for some projects (i.e. for the project where the <code>target</code>-based cache ended up taking 5GBs of space <code>sccache</code> ended up taking less than 1GB). Since <code>sccache</code> requires a bit more setup than other methods I&rsquo;ll include the full action here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>sccache</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>runs-on</span>: <span style=color:#ae81ff>ubuntu-latest</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>if</span>: <span style=color:#ae81ff>${{ inputs.sccache }}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>RUSTC_WRAPPER</span>: <span style=color:#ae81ff>sccache</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>SCCACHE_CACHE_SIZE</span>: <span style=color:#e6db74>&#34;1G&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/checkout@v2</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions-rs/toolchain@v1</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>with</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>toolchain</span>: <span style=color:#ae81ff>stable</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>override</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>taiki-e/install-action@cargo-binstall</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>run</span>: <span style=color:#ae81ff>cargo binstall --no-confirm --no-symlinks sccache</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/cache@v3</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>with</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>path</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          ~/.cargo/registry/index/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          ~/.cargo/registry/cache/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          ~/.cargo/git/db/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          ~/.cache/</span>          
</span></span><span style=display:flex><span>        <span style=color:#f92672>key</span>: <span style=color:#ae81ff>${{ runner.os }}-sccache-${{ hashFiles(&#39;**/Cargo.lock&#39;) }}</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>chetan/git-restore-mtime-action@v1</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>if</span>: <span style=color:#ae81ff>${{ inputs.restore_mtime }}</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>run</span>: <span style=color:#ae81ff>cargo test --locked --no-run</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>run</span>: <span style=color:#ae81ff>cargo test --locked --no-fail-fast</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>run</span>: <span style=color:#ae81ff>cargo clippy --locked --workspace --tests --no-deps -- -D warnings</span>
</span></span></code></pre></div><h2 id=results>Results<a href=#results class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In the end, I&rsquo;d like to bring you a comparison table of all the approaches covered here. Please note that Github Actions public runners can fluctuate in performance so I did notice some runs take up to 25% more or less time to complete without any changes to the code or action but it should still be enough to see general tendencies (it does lead to some weird results like when enabling mtime restore for <code>sccache</code> action leads to 20-40s slowdown, even though mtime doesn&rsquo;t affect the work done there in the slightest)</p><h3 id=cache-profile-overview><code>cache profile</code> overview<a href=#cache-profile-overview class=hanchor arialabel=Anchor>&#8983;</a></h3><p>I already tried to reference each profile in the article but it probably won&rsquo;t hurt to also have these definitions next to where they are used so you don&rsquo;t have to look for them each time</p><ul><li><code>home</code> - only caching recommended folders from <code>$CARGO_HOME</code> without any caching of build artifacts (eliminates <code>crates.io</code> sync)</li><li><code>home_and_target</code> - caching recommended folders from <code>$CARGO_HOME</code> + whole <code>target</code> folder</li><li><code>full</code> - caching whole <code>$CARGO_HOME</code> + whole <code>target</code> folders</li><li><code>swatinem</code> - using <code>Swatinem/rust-cache@v2</code> as is (it uses the same set of folders as <code>home_and_target</code> but does additional cleanup to only cache dependencies)</li><li><code>sccache</code> - using <code>mozilla/sccache</code> and caching recommended folders from <code>$CARGO_HOME</code> (<code>$CARGO_HOME/git/db</code>, <code>$CARGO_HOME/registry/index</code>, <code>$CARGO_HOME/registry/cache</code>) + sccache cache folder (<code>$SCCACHE_DIR</code>) without caching build artifacts themselves</li></ul><h3 id=using-sled-for-storage-happy-path>Using <code>sled</code> for storage (happy path)<a href=#using-sled-for-storage-happy-path class=hanchor arialabel=Anchor>&#8983;</a></h3><table><thead><tr><th>cache profile</th><th>cache size</th><th>toolchain + job setup time</th><th>cache sync time</th><th>first run (no cache)</th><th>second run (cache, no mtime restore)</th><th>third run (cache, mtime restore)</th></tr></thead><tbody><tr><td>home</td><td>86 mb</td><td>15s</td><td>2s</td><td>1m 50s</td><td>1m 27s</td><td>1m 27s</td></tr><tr><td>home_and_target</td><td>250 mb</td><td>15s</td><td>8s</td><td>2m 8s</td><td>31s</td><td>29s</td></tr><tr><td>full</td><td>290 mb</td><td>15s</td><td>13s</td><td>1m 56s</td><td>38s</td><td>31s</td></tr><tr><td>swatinem</td><td>250 mb</td><td>15s</td><td>9s</td><td>1m 49s</td><td>34s</td><td>27s</td></tr><tr><td>sccache</td><td>170 mb</td><td>25s</td><td>5s</td><td>2m 5s</td><td>1m 1s</td><td>1m 18s</td></tr></tbody></table><h3 id=using-rocksdb-for-storage-unhappy-path>Using <code>rocksdb</code> for storage (unhappy path)<a href=#using-rocksdb-for-storage-unhappy-path class=hanchor arialabel=Anchor>&#8983;</a></h3><table><thead><tr><th>cache profile</th><th>cache size</th><th>toolchain + job setup time</th><th>cache sync time</th><th>first run (no cache)</th><th>second run (cache, no mtime restore)</th><th>third run (cache, mtime restore)</th></tr></thead><tbody><tr><td>home</td><td>100 mb</td><td>15s</td><td>2s</td><td>8m 53s</td><td>8m 26s</td><td>8m 38s</td></tr><tr><td>home_and_target</td><td>780 mb</td><td>15s</td><td>25s</td><td>10m 11s</td><td>10m 40s</td><td>8m 28s</td></tr><tr><td>full</td><td>830 mb</td><td>15s</td><td>26s</td><td>9m 38s</td><td>56s</td><td>47s</td></tr><tr><td>swatinem</td><td>730 mb</td><td>15s</td><td>23s</td><td>9m 0s</td><td>8m 26s</td><td>10m 16s</td></tr><tr><td>sccache</td><td>490 mb</td><td>25s</td><td>10s</td><td>13m 58s</td><td>2m 10s</td><td>2m 50s</td></tr></tbody></table><p>As you can notice, until <a href=https://github.com/rust-lang/cargo/issues/11083>this</a> is resolved, the only ways to save time caching packages like <code>rocksdb</code> are caching the whole <code>$CARGO_HOME</code> folder or using a third-party tool like <code>sccache</code></p><p><strong>Shouts out to <a href=https://hachyderm.io/@predrag>Predrag Gruevski</a>, <a href=https://github.com/yneth>Anthony Bondarenko</a>, and a few folks who preferred to remain unnamed, for feedback on drafts of this post. Any mistakes are mine alone.</strong></p></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span><a rel=me href=https://github.com/arriven>Github</a>
:: <a rel=me href=https://hachyderm.io/@arriven>Mastodon</a>
:: <a rel=me href=https://www.linkedin.com/in/arriven/>LinkedIn</a>
:: <a rel=me href=mailto:inbox@arriven.wtf>Mail</a></span></div></div><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>